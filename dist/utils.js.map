{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","file":"utils.js","sourcesContent":["import {Contracts} from \"./contracts\";\nimport * as punycode from \"punycode\";\nimport AsyncResult = Contracts.AsyncResult;\nimport AgentProvider = Contracts.AgentProvider;\n\nexport async function promise<T>(value: AsyncResult<T>): Promise<T> {\n    return value;\n}\n\nfunction calPriority(agent: AgentProvider, criteria: number) {\n    return criteria / agent.weight;\n}\n\nexport function selectRandomly(agents: AgentProvider[]): AgentProvider {\n    if (agents.length === 0) {\n        return undefined;\n    }\n\n    let bias = new Map<AgentProvider, number>();\n\n    function getBias(agent) {\n        if (!bias.has(agent)) {\n            bias.set(agent, Math.random());\n        }\n        return bias.get(agent);\n    }\n\n    return agents.sort(\n        (a, b) =>\n            calPriority(a, getBias(a)) -\n            calPriority(b, getBias(b))\n    )[0];\n}\n\nexport function selectLessRequest(agents: AgentProvider[]): AgentProvider {\n    if (agents.length === 0) {\n        return undefined;\n    }\n\n    let bias = new Map<AgentProvider, number>();\n\n    function getBias(agent) {\n        if (!bias.has(agent)) {\n            bias.set(agent, Math.random());\n        }\n        return bias.get(agent);\n    }\n\n    let sorted = agents.sort(\n        (a, b) => {\n            let res = calPriority(a, a.activeRequests) -\n                calPriority(b, b.activeRequests);\n            return res === 0 ? getBias(a) - getBias(b) : res;\n        }\n    );\n\n    return sorted[0];\n}\n\ninterface MatchingResult<T>{\n    value?: T,\n    found: boolean,\n}\n\nfunction validatePattern(pattern: string){\n    let parts = pattern.split('.')\n        .map(punycode.toASCII);\n    let invalid = parts\n        .filter(p=>!['*', '**'].includes(p))\n        .some(p=>!p.length || /[^a-z0-9-_]/i.test(p));\n    if(invalid || /\\.\\*\\*/.test(pattern)){\n        throw new Error('Invalid domain pattern');\n    }\n}\n\nexport class DomainMapping<T> {\n    #mapping: Map<string, T> = new Map();\n\n    resolve(domain: string): MatchingResult<T>{\n        return this.#resolve(domain.split('.'), []);\n    }\n\n    getByPattern(pattern: string): T {\n        return this.#mapping.get(pattern);\n    }\n\n    hasPattern(pattern: string): boolean {\n        return this.#mapping.has(pattern);\n    }\n\n    addByPattern(pattern: string, value: T): this{\n        validatePattern(pattern);\n        this.#mapping.set(pattern, value);\n        return this;\n    }\n\n    removePattern(pattern: string): this{\n        validatePattern(pattern);\n        this.#mapping.delete(pattern);\n        return this;\n    }\n\n    #resolve(left: string[], right: string[]): MatchingResult<T> {\n        let subject = right.join('.');\n        if(left.length === 0){\n            return {\n                value: this.#mapping.get(subject),\n                found: this.#mapping.has(subject),\n            }\n        }\n        let sub = left.pop();\n        if(sub === '**'){\n            // When doing pattern matching, catch all should match only with catch all\n            return this.#resolve([], ['**'].concat(right));\n        }\n        let res = this.#resolve(Array.from(left), [sub].concat(right));\n        if(!res.found){\n            res = this.#resolve(Array.from(left), ['*'].concat(right));\n        }\n        if(!res.found){\n            res = this.#resolve([], ['**'].concat(right));\n        }\n        return res;\n    }\n}\n"]}