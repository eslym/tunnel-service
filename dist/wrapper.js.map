{"version":3,"sources":["../src/wrapper.ts"],"names":[],"mappings":"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","file":"wrapper.js","sourcesContent":["import {Contracts} from \"./contracts\";\nimport {AuthContext, PublicKeyAuthContext} from \"ssh2\";\nimport {promise} from \"./utils\";\nimport {Agent} from \"http\";\nimport {Request, Response} from \"express\";\n\nconst wrapped = new WeakMap();\n\nfunction wrap<T>(target: any, type: new (v: any)=>T){\n    if(typeof target !== 'object'){\n        return target\n    }\n    if(target instanceof type){\n        return target;\n    }\n    if(!wrapped.has(target)){\n        wrapped.set(target, new type(target));\n    }\n    return wrapped.get(target);\n}\n\n/**\n * SafeWrapped Namespace\n *\n * Wrap contracts object and only expose the API\n */\nexport namespace SafeWrapped {\n    import P = Contracts.AsyncResult;\n    import Protocol = Contracts.Protocol;\n\n    export class User implements Contracts.User{\n        readonly #user: Contracts.User;\n\n        constructor(user: Contracts.User) {\n            this.#user = user;\n        }\n\n        get username(): string {\n            return this.#user.username;\n        }\n\n        authKey(context: PublicKeyAuthContext): P<boolean> {\n            return this.#user.authKey(context);\n        }\n\n        authPassword(password: string): P<boolean> {\n            return this.#user.authPassword(password);\n        }\n\n        canBind(domain: string, protocol: Protocol): P<boolean> {\n            return this.#user.canBind(domain, protocol);\n        }\n\n        static wrap(user?: Contracts.User){\n            return wrap(user, User);\n        }\n    }\n\n    export class ClientConnection implements Contracts.ClientConnection{\n        readonly #client: Contracts.ClientConnection;\n\n        constructor(client: Contracts.ClientConnection) {\n            this.#client = client;\n        }\n\n        get uuid(): string {\n            return this.#client.uuid;\n        }\n\n        get user(): Contracts.User {\n            return User.wrap(this.#client.user);\n        }\n\n        get authenticatedContext(): AuthContext{\n            return this.#client.authenticatedContext;\n        }\n\n        get agents(): Contracts.AgentProvider[] {\n            return this.#client.agents.map(AgentProvider.wrap);\n        }\n\n        get activeRequests(): number {\n            return this.#client.activeRequests;\n        }\n\n        get state(): 'active' | 'pausing' | 'shutting-down'{\n            return this.#client.state;\n        }\n\n        log(message: string, force?: boolean): Contracts.AsyncResult<void> {\n            return this.#client.log(message, force);\n        }\n\n        isBound(domain: string, protocol: Contracts.Protocol): boolean {\n            return this.#client.isBound(domain, protocol);\n        }\n\n        static wrap(client?: Contracts.ClientConnection){\n            return wrap(client, ClientConnection);\n        }\n    }\n\n    export class UserProvider implements Contracts.UserProvider {\n        readonly #provider: Contracts.UserProvider;\n\n        constructor(provider: Contracts.UserProvider) {\n            this.#provider = provider;\n        }\n\n        findUser(username: string, client: Contracts.ClientConnection): Contracts.AsyncResult<Contracts.User | false> {\n            return promise(this.#provider.findUser(username, client)).then(User.wrap);\n        }\n\n        off(event: 'user-deactivated', listener: (username: string)=>void): this {\n            this.#provider.off(event, listener);\n            return this;\n        }\n\n        on(event: 'user-deactivated', listener: (username: string)=>void): this {\n            this.#provider.on(event, listener);\n            return this;\n        }\n\n        once(event: 'user-deactivated', listener: (username: string)=>void): this {\n            this.#provider.once(event, listener);\n            return this;\n        }\n\n        static wrap(provider?: Contracts.UserProvider){\n            return wrap(provider, UserProvider);\n        }\n    }\n\n    export class AgentProvider implements Contracts.AgentProvider {\n        readonly #agent: Contracts.AgentProvider;\n\n        constructor(agent: Contracts.AgentProvider) {\n            this.#agent = agent;\n        }\n\n        get uuid(): string{\n            return this.#agent.uuid;\n        }\n\n        get client(): Contracts.ClientConnection{\n            return ClientConnection.wrap(this.#agent.client);\n        }\n\n        get protocol(): Contracts.Protocol {\n            return this.#agent.protocol;\n        }\n\n        get weight(): number {\n            return this.#agent.weight;\n        }\n\n        get activeRequests(): number {\n            return this.#agent.activeRequests;\n        }\n\n        get binding(): string {\n            return this.#agent.binding;\n        }\n\n        get state(): 'active' | 'pausing' | 'shutting-down'{\n            return this.#agent.state;\n        }\n\n        getAgent(sourceIp: string, sourcePort: number): Contracts.AsyncResult<Agent> {\n            return this.#agent.getAgent(sourceIp, sourcePort);\n        }\n\n        static wrap(agent: Contracts.AgentProvider){\n            return wrap(agent, AgentProvider);\n        }\n    }\n\n    export class AgentPool implements Contracts.AgentPool {\n        readonly #pool: Contracts.AgentPool;\n\n        constructor(pool: Contracts.AgentPool) {\n            this.#pool = pool;\n        }\n\n        attach(agent: Contracts.AgentProvider): Contracts.AsyncResult<void> {\n            let pool = this.#pool;\n            let p = AgentProvider.wrap(agent);\n            return pool.attach(p);\n        }\n\n        detach(agent: Contracts.AgentProvider): Contracts.AsyncResult<void> {\n            return this.#pool.detach(AgentProvider.wrap(agent));\n        }\n\n        detachAll(client: Contracts.ClientConnection): Contracts.AsyncResult<void> {\n            return this.#pool.detachAll(ClientConnection.wrap(client));\n        }\n\n        select(domain: string): Contracts.AsyncResult<Contracts.AgentProvider | false> {\n            return promise(this.#pool.select(domain))\n                .then(a => a ? AgentProvider.wrap(a) : false);\n        }\n\n        isAvailable(domain: string): Contracts.AsyncResult<boolean> {\n            return this.#pool.isAvailable(domain);\n        }\n\n        static wrap(pool: Contracts.AgentPool){\n            return wrap(pool, AgentPool);\n        }\n    }\n\n    export class ErrorResponseHandler implements Contracts.ErrorResponseHandler {\n        readonly #handler: Contracts.ErrorResponseHandler;\n\n        constructor(handler: Contracts.ErrorResponseHandler) {\n            this.#handler = handler;\n        }\n\n        badGateway(request: Request, response: Response): Contracts.AsyncResult<void> {\n            return this.#handler.badGateway(request, response);\n        }\n\n        serviceUnavailable(request: Request, response: Response): Contracts.AsyncResult<void> {\n            return this.#handler.serviceUnavailable(request, response);\n        }\n\n        gatewayTimeout(request: Request, response: Response): Contracts.AsyncResult<void> {\n            return this.#handler.gatewayTimeout(request, response);\n        }\n\n        static wrap(handler: Contracts.ErrorResponseHandler){\n            return wrap(handler, ErrorResponseHandler);\n        }\n    }\n}\n"]}